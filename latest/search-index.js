var searchIndex = {};
searchIndex["lumol"] = {"doc":"Lumol is a classical molecular simulation engine that provides a solid base for developing new algorithms and methods.","items":[[0,"units","lumol","This module allow to convert from and to the internal unit system.",null,null],[4,"ParseError","lumol::units","Possible error causes when parsing an unit string.",null,null],[13,"Power","","Error while parsing a power in `x^y` expressions",0,null],[13,"Value","","Error while parsing the value part of an unit string",0,null],[13,"ParenthesesMismatch","","Parentheses are not balanced in this unit",0,null],[13,"NotFound","","This unit was not found",0,null],[12,"unit","lumol::units::ParseError","The unit that created this error",0,null],[13,"MalformedExpr","lumol::units","Any other error",0,null],[5,"from","","Convert the numeric value `val` from the unit `unit` to the internal unit.",null,{"inputs":[{"name":"f64"},{"name":"str"}],"output":{"name":"result"}}],[5,"from_str","","Parse the string `val` and convert it to the corresponding internal unit",null,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[5,"to","","Convert the numeric value `val` (in internal units) to the unit `unit`.",null,{"inputs":[{"name":"f64"},{"name":"str"}],"output":{"name":"result"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",0,{"inputs":[{"name":"parseinterror"}],"output":{"name":"parseerror"}}],[11,"from","","",0,{"inputs":[{"name":"parsefloaterror"}],"output":{"name":"parseerror"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","",0,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[0,"consts","lumol","Useful physical constants, expressed in the internal unit system.",null,null],[17,"K_BOLTZMANN","lumol::consts","Boltzmann constant",null,null],[17,"BOHR_RADIUS","","Bohr radius",null,null],[17,"NA","","Avogadro number",null,null],[17,"ELCC","","4 * pi * epsilon_0",null,null],[0,"types","lumol","Linear algebra types for Lumol.",null,null],[8,"One","lumol::types","Defines a multiplicative identity element for `Self`.",null,null],[10,"one","","Returns the multiplicative identity element of `Self`, `1`.",1,{"inputs":[],"output":{"name":"self"}}],[8,"Zero","","Defines an additive identity element for `Self`.",null,null],[10,"zero","","Returns the additive identity element of `Self`, `0`.",2,{"inputs":[],"output":{"name":"self"}}],[10,"is_zero","","Returns `true` if `self` is equal to the additive identity.",2,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[3,"Vector3D","","A 3-dimensional vector type",null,null],[3,"Matrix3","","A 3x3 square matrix type.",null,null],[3,"Complex","","Complex number, with double precision real and imaginary parts.",null,null],[3,"Array2","","Two dimensional tensors, based on ndarray.",null,null],[3,"Array3","","Three dimensional tensors, based on ndarray",null,null],[11,"clone","","",3,{"inputs":[{"name":"self"}],"output":{"name":"vector3d"}}],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Create a new `Vector3D` with components `x`, `y`, `z`",3,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"vector3d"}}],[11,"norm2","","Return the squared euclidean norm of a `Vector3D`",3,{"inputs":[{"name":"self"}],"output":{"name":"f64"}}],[11,"norm","","Return the euclidean norm of a `Vector3D` # Examples `# use lumol::types::Vector3D; # use std::f64; let vec = Vector3D::new(1.0, 0.0, -4.0); assert_eq!(vec.norm(), f64::sqrt(17.0));`",3,{"inputs":[{"name":"self"}],"output":{"name":"f64"}}],[11,"normalized","","Normalize a `Vector3D`. # Examples `# use lumol::types::Vector3D; let vec = Vector3D::new(1.0, 0.0, -4.0); let n = vec.normalized(); assert_eq!(n.norm(), 1.0);`",3,{"inputs":[{"name":"self"}],"output":{"name":"vector3d"}}],[11,"tensorial","","Tensorial product between vectors. The tensorial product between the vectors `a` and `b` creates a `Matrix3` with component (i, j) equals to `a[i] * b[j]`.",3,{"inputs":[{"name":"self"},{"name":"vector3d"}],"output":{"name":"matrix3"}}],[11,"add","","",3,{"inputs":[{"name":"self"},{"name":"vector3d"}],"output":{"name":"vector3d"}}],[11,"add","","",3,{"inputs":[{"name":"self"},{"name":"vector3d"}],"output":{"name":"vector3d"}}],[11,"add","","",3,{"inputs":[{"name":"self"},{"name":"vector3d"}],"output":{"name":"vector3d"}}],[11,"add_assign","","",3,{"inputs":[{"name":"self"},{"name":"vector3d"}],"output":null}],[11,"add_assign","","",3,{"inputs":[{"name":"self"},{"name":"vector3d"}],"output":null}],[11,"add_assign","","",3,{"inputs":[{"name":"self"},{"name":"vector3d"}],"output":null}],[11,"sub","","",3,{"inputs":[{"name":"self"},{"name":"vector3d"}],"output":{"name":"vector3d"}}],[11,"sub","","",3,{"inputs":[{"name":"self"},{"name":"vector3d"}],"output":{"name":"vector3d"}}],[11,"sub","","",3,{"inputs":[{"name":"self"},{"name":"vector3d"}],"output":{"name":"vector3d"}}],[11,"sub_assign","","",3,{"inputs":[{"name":"self"},{"name":"vector3d"}],"output":null}],[11,"sub_assign","","",3,{"inputs":[{"name":"self"},{"name":"vector3d"}],"output":null}],[11,"sub_assign","","",3,{"inputs":[{"name":"self"},{"name":"vector3d"}],"output":null}],[11,"mul","","",3,{"inputs":[{"name":"self"},{"name":"vector3d"}],"output":{"name":"f64"}}],[11,"mul","","",3,{"inputs":[{"name":"self"},{"name":"vector3d"}],"output":{"name":"f64"}}],[11,"mul","","",3,{"inputs":[{"name":"self"},{"name":"vector3d"}],"output":{"name":"f64"}}],[11,"bitxor","","",3,{"inputs":[{"name":"self"},{"name":"vector3d"}],"output":{"name":"vector3d"}}],[11,"bitxor","","",3,{"inputs":[{"name":"self"},{"name":"vector3d"}],"output":{"name":"vector3d"}}],[11,"bitxor","","",3,{"inputs":[{"name":"self"},{"name":"vector3d"}],"output":{"name":"vector3d"}}],[11,"mul","","",3,{"inputs":[{"name":"self"},{"name":"f64"}],"output":{"name":"vector3d"}}],[11,"mul_assign","","",3,{"inputs":[{"name":"self"},{"name":"f64"}],"output":null}],[11,"mul_assign","","",3,{"inputs":[{"name":"self"},{"name":"f64"}],"output":null}],[11,"mul_assign","","",3,{"inputs":[{"name":"self"},{"name":"f64"}],"output":null}],[11,"div","","",3,{"inputs":[{"name":"self"},{"name":"f64"}],"output":{"name":"vector3d"}}],[11,"div_assign","","",3,{"inputs":[{"name":"self"},{"name":"f64"}],"output":null}],[11,"div_assign","","",3,{"inputs":[{"name":"self"},{"name":"f64"}],"output":null}],[11,"div_assign","","",3,{"inputs":[{"name":"self"},{"name":"f64"}],"output":null}],[11,"neg","","",3,{"inputs":[{"name":"self"}],"output":{"name":"vector3d"}}],[11,"eq","","",3,{"inputs":[{"name":"self"},{"name":"vector3d"}],"output":{"name":"bool"}}],[11,"index","","",3,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"f64"}}],[11,"index_mut","","",3,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"f64"}}],[11,"zero","","",3,{"inputs":[],"output":{"name":"vector3d"}}],[11,"is_zero","","",3,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"clone","","",4,{"inputs":[{"name":"self"}],"output":{"name":"matrix3"}}],[11,"fmt","","",4,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",4,{"inputs":[{"name":"self"},{"name":"matrix3"}],"output":{"name":"bool"}}],[11,"ne","","",4,{"inputs":[{"name":"self"},{"name":"matrix3"}],"output":{"name":"bool"}}],[11,"new","","Create a new `Matrix3` specifying all its components # Examples `# use lumol::types::Matrix3; let matrix = Matrix3::new( 0.0, 0.0, 3.0, 0.0, 1.0, 5.6, 0.0, 0.0, 7.0 ); assert_eq!(matrix[0][2], 3.0);`",4,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"matrix3"}}],[11,"rotation","","Returns rotation matrix given a rotation angle and an axis.",4,{"inputs":[{"name":"vector3d"},{"name":"f64"}],"output":{"name":"matrix3"}}],[11,"trace","","Compute the trace of the matrix # Examples `# use lumol::types::Matrix3; let matrix = Matrix3::new( 0.0, 0.0, 3.0, 0.0, 1.0, 5.6, 0.0, 0.0, 7.0 ); assert_eq!(matrix.trace(), 8.0);`",4,{"inputs":[{"name":"self"}],"output":{"name":"f64"}}],[11,"inverse","","Computes the inverse of a matrix",4,{"inputs":[{"name":"self"}],"output":{"name":"matrix3"}}],[11,"determinant","","Computes the [determinant][Wiki] of a matrix",4,{"inputs":[{"name":"self"}],"output":{"name":"f64"}}],[11,"transposed","","Transpose this matrix into a new matrix # Examples",4,{"inputs":[{"name":"self"}],"output":{"name":"matrix3"}}],[11,"index","","",4,null],[11,"index","","",4,null],[11,"index_mut","","",4,null],[11,"index_mut","","",4,null],[11,"add","","",4,{"inputs":[{"name":"self"},{"name":"matrix3"}],"output":{"name":"matrix3"}}],[11,"add","","",4,{"inputs":[{"name":"self"},{"name":"matrix3"}],"output":{"name":"matrix3"}}],[11,"add","","",4,{"inputs":[{"name":"self"},{"name":"matrix3"}],"output":{"name":"matrix3"}}],[11,"add_assign","","",4,{"inputs":[{"name":"self"},{"name":"matrix3"}],"output":null}],[11,"add_assign","","",4,{"inputs":[{"name":"self"},{"name":"matrix3"}],"output":null}],[11,"add_assign","","",4,{"inputs":[{"name":"self"},{"name":"matrix3"}],"output":null}],[11,"sub","","",4,{"inputs":[{"name":"self"},{"name":"matrix3"}],"output":{"name":"matrix3"}}],[11,"sub","","",4,{"inputs":[{"name":"self"},{"name":"matrix3"}],"output":{"name":"matrix3"}}],[11,"sub","","",4,{"inputs":[{"name":"self"},{"name":"matrix3"}],"output":{"name":"matrix3"}}],[11,"sub_assign","","",4,{"inputs":[{"name":"self"},{"name":"matrix3"}],"output":null}],[11,"sub_assign","","",4,{"inputs":[{"name":"self"},{"name":"matrix3"}],"output":null}],[11,"sub_assign","","",4,{"inputs":[{"name":"self"},{"name":"matrix3"}],"output":null}],[11,"mul","","",4,{"inputs":[{"name":"self"},{"name":"matrix3"}],"output":{"name":"matrix3"}}],[11,"mul","","",4,{"inputs":[{"name":"self"},{"name":"matrix3"}],"output":{"name":"matrix3"}}],[11,"mul","","",4,{"inputs":[{"name":"self"},{"name":"matrix3"}],"output":{"name":"matrix3"}}],[11,"mul_assign","","",4,{"inputs":[{"name":"self"},{"name":"matrix3"}],"output":null}],[11,"mul_assign","","",4,{"inputs":[{"name":"self"},{"name":"matrix3"}],"output":null}],[11,"mul_assign","","",4,{"inputs":[{"name":"self"},{"name":"matrix3"}],"output":null}],[11,"mul","","",4,{"inputs":[{"name":"self"},{"name":"vector3d"}],"output":{"name":"vector3d"}}],[11,"mul","","",4,{"inputs":[{"name":"self"},{"name":"vector3d"}],"output":{"name":"vector3d"}}],[11,"mul","","",4,{"inputs":[{"name":"self"},{"name":"vector3d"}],"output":{"name":"vector3d"}}],[11,"mul","","",4,{"inputs":[{"name":"self"},{"name":"f64"}],"output":{"name":"matrix3"}}],[11,"mul_assign","","",4,{"inputs":[{"name":"self"},{"name":"f64"}],"output":null}],[11,"mul_assign","","",4,{"inputs":[{"name":"self"},{"name":"f64"}],"output":null}],[11,"mul_assign","","",4,{"inputs":[{"name":"self"},{"name":"f64"}],"output":null}],[11,"div","","",4,{"inputs":[{"name":"self"},{"name":"f64"}],"output":{"name":"matrix3"}}],[11,"div_assign","","",4,{"inputs":[{"name":"self"},{"name":"f64"}],"output":null}],[11,"div_assign","","",4,{"inputs":[{"name":"self"},{"name":"f64"}],"output":null}],[11,"div_assign","","",4,{"inputs":[{"name":"self"},{"name":"f64"}],"output":null}],[11,"zero","","",4,{"inputs":[],"output":{"name":"matrix3"}}],[11,"is_zero","","",4,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"one","","Create an identity matrix",4,{"inputs":[],"output":{"name":"matrix3"}}],[11,"sum","","",4,{"inputs":[{"name":"i"}],"output":{"name":"self"}}],[11,"fmt","","",5,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",5,{"inputs":[{"name":"self"}],"output":{"name":"complex"}}],[11,"eq","","",5,{"inputs":[{"name":"self"},{"name":"complex"}],"output":{"name":"bool"}}],[11,"ne","","",5,{"inputs":[{"name":"self"},{"name":"complex"}],"output":{"name":"bool"}}],[11,"default","","",5,{"inputs":[],"output":{"name":"complex"}}],[11,"polar","","Create a new `Complex` from a norm `r` and a phase `phi` in radians. # Examples `# use lumol::types::Complex; # use std::f64; let z = Complex::polar(3.0, f64::consts::PI); assert_eq!(z.norm(), 3.0);`",5,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"complex"}}],[11,"cartesian","","Create a complex from Cartesian coordinates # Examples `# use lumol::types::Complex; let z = Complex::cartesian(3.0, -2.0); assert_eq!(z.real(), 3.0); assert_eq!(z.imag(), -2.0);`",5,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"complex"}}],[11,"real","","Get the real part of the complex # Examples `# use lumol::types::Complex; let z = Complex::cartesian(3.0, -2.0); assert_eq!(z.real(), 3.0);`",5,{"inputs":[{"name":"self"}],"output":{"name":"f64"}}],[11,"imag","","Get the imaginary part of the complex # Examples `# use lumol::types::Complex; let z = Complex::cartesian(3.0, -2.0); assert_eq!(z.imag(), -2.0);`",5,{"inputs":[{"name":"self"}],"output":{"name":"f64"}}],[11,"phase","","Get the phase of the complex in the [-π, π) interval # Examples `# use lumol::types::Complex; let z = Complex::polar(2.0, 0.3); assert_eq!(z.phase(), 0.3);`",5,{"inputs":[{"name":"self"}],"output":{"name":"f64"}}],[11,"norm","","Get the norm of the complex # Examples ``` # use lumol::types::Complex; # use std::f64; let z = Complex::polar(2.0, 0.3); assert_eq!(z.norm(), 2.0);",5,{"inputs":[{"name":"self"}],"output":{"name":"f64"}}],[11,"norm2","","Get the square of the norm if this complex # Examples `# use lumol::types::Complex; let z = Complex::cartesian(2.0, 1.0); assert_eq!(z.norm2(), 5.0);`",5,{"inputs":[{"name":"self"}],"output":{"name":"f64"}}],[11,"conj","","Get the conjugate of the complex # Examples `# use lumol::types::Complex; let z = Complex::cartesian(2.0, 1.0); assert_eq!(z.conj(), Complex::cartesian(2.0, -1.0));`",5,{"inputs":[{"name":"self"}],"output":{"name":"complex"}}],[11,"add","","",5,{"inputs":[{"name":"self"},{"name":"complex"}],"output":{"name":"complex"}}],[11,"sub","","",5,{"inputs":[{"name":"self"},{"name":"complex"}],"output":{"name":"complex"}}],[11,"neg","","",5,{"inputs":[{"name":"self"}],"output":{"name":"complex"}}],[11,"mul","","",5,{"inputs":[{"name":"self"},{"name":"complex"}],"output":{"name":"complex"}}],[11,"mul","","",5,{"inputs":[{"name":"self"},{"name":"f64"}],"output":{"name":"complex"}}],[11,"div","","",5,{"inputs":[{"name":"self"},{"name":"complex"}],"output":{"name":"complex"}}],[11,"div","","",5,{"inputs":[{"name":"self"},{"name":"f64"}],"output":{"name":"complex"}}],[11,"zero","","",5,{"inputs":[],"output":{"name":"complex"}}],[11,"is_zero","","",5,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"one","","",5,{"inputs":[],"output":{"name":"complex"}}],[11,"fmt","","",6,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",6,{"inputs":[{"name":"self"}],"output":{"name":"array2"}}],[11,"eq","","",6,{"inputs":[{"name":"self"},{"name":"array2"}],"output":{"name":"bool"}}],[11,"ne","","",6,{"inputs":[{"name":"self"},{"name":"array2"}],"output":{"name":"bool"}}],[11,"zeros","","Create a new `Array2` of the specified `size` filled with the `Zero::zero` return value.",6,null],[11,"resize_if_different","","Resize the array if the current size is not `size`, and fill the new array with zeros.",6,null],[11,"default","","Create a new `Array2` of the specified `size` filled with the `Default::default` return value.",6,null],[11,"index","","",6,null],[11,"index_mut","","",6,null],[11,"deref","","",6,{"inputs":[{"name":"self"}],"output":{"name":"array2"}}],[11,"deref_mut","","",6,{"inputs":[{"name":"self"}],"output":{"name":"array2"}}],[11,"fmt","","",7,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",7,{"inputs":[{"name":"self"}],"output":{"name":"array3"}}],[11,"eq","","",7,{"inputs":[{"name":"self"},{"name":"array3"}],"output":{"name":"bool"}}],[11,"ne","","",7,{"inputs":[{"name":"self"},{"name":"array3"}],"output":{"name":"bool"}}],[11,"zeros","","Create a new `Array3` of the specified `size` filled with the `Zero::zero` return value.",7,null],[11,"resize_if_different","","Resize the array if the current size is not `size`, and fill the new array with zeros.",7,null],[11,"default","","Create a new `Array3` of the specified `size` filled with the `Default::default` return value. `Default::default` return value.",7,null],[11,"index","","",7,null],[11,"index_mut","","",7,null],[11,"deref","","",7,{"inputs":[{"name":"self"}],"output":{"name":"array3"}}],[11,"deref_mut","","",7,{"inputs":[{"name":"self"}],"output":{"name":"array3"}}],[0,"energy","lumol","Interaction potentials for energy and forces computations",null,null],[3,"NullPotential","lumol::energy","No-op potential.",null,null],[3,"LennardJones","","Lennard-Jones potential.",null,null],[12,"sigma","","Distance constant of the Lennard-Jones potential",8,null],[12,"epsilon","","Energy constant of the Lennard-Jones potential",8,null],[3,"Harmonic","","Harmonic potential.",null,null],[12,"k","","Spring constant",9,null],[12,"x0","","Equilibrium value",9,null],[3,"CosineHarmonic","","Cosine harmonic potential.",null,null],[3,"Torsion","","Torsion potential.",null,null],[12,"k","","Force constant",10,null],[12,"delta","","Equilibrium value",10,null],[12,"n","","Multiplicity of the potential",10,null],[3,"Buckingham","","Buckingham potential.",null,null],[12,"a","","Exponential term energetic constant",11,null],[12,"c","","`1/r^6` term energetic constant",11,null],[12,"rho","","Width of the exponential term length constant",11,null],[3,"BornMayerHuggins","","Born-Mayer-Huggins potential.",null,null],[12,"a","","Exponential term energetic constant",12,null],[12,"c","","`1/r^6` term energetic constant",12,null],[12,"d","","`1/r^8` term energetic constant",12,null],[12,"sigma","","Sphere diameter length constant",12,null],[12,"rho","","Width of the exponential term length constant",12,null],[3,"MorsePotential","","Morse potential",null,null],[12,"a","","Exponential term width value",13,null],[12,"x0","","Equilibrium value",13,null],[12,"depth","","Well depth value",13,null],[3,"TableComputation","","Computation of a potential using tabulated values.",null,null],[3,"RestrictionInfo","","Restriction information attached to a pair of `Particles` in a `System`.",null,null],[12,"excluded","","Is this pair excluded?",14,null],[12,"scaling","","Scaling factor for the potential. This value is contained between 0 and 1.",14,null],[3,"Wolf","","Wolf summation for coulombic interactions.",null,null],[3,"Ewald","","Ewald summation for coulombic interactions.",null,null],[3,"SharedEwald","","Thread-sade wrapper around Ewald implementing `CoulombicPotential`.",null,null],[3,"PairInteraction","","A non-bonded interaction between two particle.",null,null],[4,"PairRestriction","","Possible restrictions on the pair interactions.",null,null],[13,"None","","No pair should be excluded.",15,null],[13,"IntraMolecular","","Only apply the interaction to intra-molecular pairs.",15,null],[13,"InterMolecular","","Only apply the interaction to inter-molecular pairs.",15,null],[13,"Exclude12","","Only apply the interaction to pairs which are not in 1-2 position (separated by one bond).",15,null],[13,"Exclude13","","Only apply the interaction to pairs which are not in 1-2 or 1-3 position (separated by one or two bonds).",15,null],[13,"Exclude14","","Only apply the interaction to pairs which are not in 1-2, 1-3 or 1-4 position (separated by one, two or three bonds).",15,null],[13,"Scale14","","Only apply the interaction to pairs which are not in 1-2 or 1-3 position, and scale the interaction for pairs in 1-4 position (separated by three bonds).",15,null],[11,"clone","","",16,{"inputs":[{"name":"self"}],"output":{"name":"nullpotential"}}],[11,"energy","","",16,{"inputs":[{"name":"self"},{"name":"f64"}],"output":{"name":"f64"}}],[11,"force","","",16,{"inputs":[{"name":"self"},{"name":"f64"}],"output":{"name":"f64"}}],[11,"tail_energy","","",16,{"inputs":[{"name":"self"},{"name":"f64"}],"output":{"name":"f64"}}],[11,"tail_virial","","",16,{"inputs":[{"name":"self"},{"name":"f64"}],"output":{"name":"f64"}}],[11,"clone","","",8,{"inputs":[{"name":"self"}],"output":{"name":"lennardjones"}}],[11,"energy","","",8,{"inputs":[{"name":"self"},{"name":"f64"}],"output":{"name":"f64"}}],[11,"force","","",8,{"inputs":[{"name":"self"},{"name":"f64"}],"output":{"name":"f64"}}],[11,"tail_energy","","",8,{"inputs":[{"name":"self"},{"name":"f64"}],"output":{"name":"f64"}}],[11,"tail_virial","","",8,{"inputs":[{"name":"self"},{"name":"f64"}],"output":{"name":"f64"}}],[11,"clone","","",9,{"inputs":[{"name":"self"}],"output":{"name":"harmonic"}}],[11,"energy","","",9,{"inputs":[{"name":"self"},{"name":"f64"}],"output":{"name":"f64"}}],[11,"force","","",9,{"inputs":[{"name":"self"},{"name":"f64"}],"output":{"name":"f64"}}],[11,"tail_energy","","",9,{"inputs":[{"name":"self"},{"name":"f64"}],"output":{"name":"f64"}}],[11,"tail_virial","","",9,{"inputs":[{"name":"self"},{"name":"f64"}],"output":{"name":"f64"}}],[11,"clone","","",17,{"inputs":[{"name":"self"}],"output":{"name":"cosineharmonic"}}],[11,"new","","Create a new `CosineHarmonic` potentials, with elastic constant of `k` and equilibrium value of `x0`",17,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"cosineharmonic"}}],[11,"energy","","",17,{"inputs":[{"name":"self"},{"name":"f64"}],"output":{"name":"f64"}}],[11,"force","","",17,{"inputs":[{"name":"self"},{"name":"f64"}],"output":{"name":"f64"}}],[11,"clone","","",10,{"inputs":[{"name":"self"}],"output":{"name":"torsion"}}],[11,"energy","","",10,{"inputs":[{"name":"self"},{"name":"f64"}],"output":{"name":"f64"}}],[11,"force","","",10,{"inputs":[{"name":"self"},{"name":"f64"}],"output":{"name":"f64"}}],[11,"clone","","",11,{"inputs":[{"name":"self"}],"output":{"name":"buckingham"}}],[11,"energy","","",11,{"inputs":[{"name":"self"},{"name":"f64"}],"output":{"name":"f64"}}],[11,"force","","",11,{"inputs":[{"name":"self"},{"name":"f64"}],"output":{"name":"f64"}}],[11,"tail_energy","","",11,{"inputs":[{"name":"self"},{"name":"f64"}],"output":{"name":"f64"}}],[11,"tail_virial","","",11,{"inputs":[{"name":"self"},{"name":"f64"}],"output":{"name":"f64"}}],[11,"clone","","",12,{"inputs":[{"name":"self"}],"output":{"name":"bornmayerhuggins"}}],[11,"energy","","",12,{"inputs":[{"name":"self"},{"name":"f64"}],"output":{"name":"f64"}}],[11,"force","","",12,{"inputs":[{"name":"self"},{"name":"f64"}],"output":{"name":"f64"}}],[11,"tail_energy","","",12,{"inputs":[{"name":"self"},{"name":"f64"}],"output":{"name":"f64"}}],[11,"tail_virial","","",12,{"inputs":[{"name":"self"},{"name":"f64"}],"output":{"name":"f64"}}],[11,"clone","","",13,{"inputs":[{"name":"self"}],"output":{"name":"morsepotential"}}],[11,"energy","","",13,{"inputs":[{"name":"self"},{"name":"f64"}],"output":{"name":"f64"}}],[11,"force","","",13,{"inputs":[{"name":"self"},{"name":"f64"}],"output":{"name":"f64"}}],[11,"tail_energy","","",13,{"inputs":[{"name":"self"},{"name":"f64"}],"output":{"name":"f64"}}],[11,"tail_virial","","",13,{"inputs":[{"name":"self"},{"name":"f64"}],"output":{"name":"f64"}}],[11,"clone","","",18,{"inputs":[{"name":"self"}],"output":{"name":"tablecomputation"}}],[11,"new","","Create a new `TableComputation` for `potential`, with `size` points and a maximum value of `max`.",18,{"inputs":[{"name":"box"},{"name":"usize"},{"name":"f64"}],"output":{"name":"tablecomputation"}}],[11,"compute_energy","","",18,{"inputs":[{"name":"self"},{"name":"f64"}],"output":{"name":"f64"}}],[11,"compute_force","","",18,{"inputs":[{"name":"self"},{"name":"f64"}],"output":{"name":"f64"}}],[11,"tail_energy","","",18,{"inputs":[{"name":"self"},{"name":"f64"}],"output":{"name":"f64"}}],[11,"tail_virial","","",18,{"inputs":[{"name":"self"},{"name":"f64"}],"output":{"name":"f64"}}],[11,"clone","","",15,{"inputs":[{"name":"self"}],"output":{"name":"pairrestriction"}}],[11,"fmt","","",15,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",15,{"inputs":[{"name":"self"},{"name":"pairrestriction"}],"output":{"name":"bool"}}],[11,"ne","","",15,{"inputs":[{"name":"self"},{"name":"pairrestriction"}],"output":{"name":"bool"}}],[11,"clone","","",14,{"inputs":[{"name":"self"}],"output":{"name":"restrictioninfo"}}],[11,"fmt","","",14,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"information","","Get the restriction at the given [bond `distance`][distance].",15,{"inputs":[{"name":"self"},{"name":"i8"}],"output":{"name":"restrictioninfo"}}],[11,"clone","","",19,{"inputs":[{"name":"self"}],"output":{"name":"wolf"}}],[11,"new","","Create a new Wolf summation, using a real-space cutoff of `cutoff`.",19,{"inputs":[{"name":"f64"}],"output":{"name":"wolf"}}],[11,"move_particles_cost","","",19,null],[11,"update","","",19,{"inputs":[{"name":"self"}],"output":null}],[11,"cutoff","","",19,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"energy","","",19,{"inputs":[{"name":"self"},{"name":"configuration"}],"output":{"name":"f64"}}],[11,"forces","","",19,null],[11,"virial","","",19,{"inputs":[{"name":"self"},{"name":"configuration"}],"output":{"name":"matrix3"}}],[11,"set_restriction","","",19,{"inputs":[{"name":"self"},{"name":"pairrestriction"}],"output":null}],[11,"clone","","",20,{"inputs":[{"name":"self"}],"output":{"name":"ewald"}}],[11,"fmt","","",20,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Create an Ewald summation using the given `cutoff` radius in real space, and `kmax` points in k-space (Fourier space).",20,{"inputs":[{"name":"f64"},{"name":"usize"}],"output":{"name":"ewald"}}],[11,"set_alpha","","Set the value of the alpha parameter for ewald computation. The default is to use `alpha = 3 * π / (4 * rc)`.",20,{"inputs":[{"name":"self"},{"name":"f64"}],"output":null}],[11,"new","","Wrap `ewald` in a thread-safe structure.",21,{"inputs":[{"name":"ewald"}],"output":{"name":"sharedewald"}}],[11,"clone","","",21,{"inputs":[{"name":"self"}],"output":{"name":"sharedewald"}}],[11,"cutoff","","",21,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"energy","","",21,{"inputs":[{"name":"self"},{"name":"configuration"}],"output":{"name":"f64"}}],[11,"forces","","",21,null],[11,"virial","","",21,{"inputs":[{"name":"self"},{"name":"configuration"}],"output":{"name":"matrix3"}}],[11,"set_restriction","","",21,{"inputs":[{"name":"self"},{"name":"pairrestriction"}],"output":null}],[11,"move_particles_cost","","",21,null],[11,"update","","",21,{"inputs":[{"name":"self"}],"output":null}],[11,"clone","","",22,{"inputs":[{"name":"self"}],"output":{"name":"pairinteraction"}}],[11,"new","","Create a new `PairInteraction` for the given `potential` and using the given `cutoff` distance.",22,{"inputs":[{"name":"box"},{"name":"f64"}],"output":{"name":"pairinteraction"}}],[11,"shifted","","Create a new `PairInteraction` with the given `cutoff`, using shifted computation of the energy.",22,{"inputs":[{"name":"box"},{"name":"f64"}],"output":{"name":"pairinteraction"}}],[11,"enable_tail_corrections","","Enable the use of tail corrections for energy and virial contribution of this pair interaction.",22,{"inputs":[{"name":"self"}],"output":null}],[11,"restriction","","Get the associated pair restriction. The default is to have no pair restriction.",22,{"inputs":[{"name":"self"}],"output":{"name":"pairrestriction"}}],[11,"set_restriction","","Set the pair restriction associated with this interaction.",22,{"inputs":[{"name":"self"},{"name":"pairrestriction"}],"output":null}],[11,"cutoff","","Return the cutoff radius",22,{"inputs":[{"name":"self"}],"output":{"name":"f64"}}],[11,"energy","","Get the energy for this pair interaction at the distance `r`.",22,{"inputs":[{"name":"self"},{"name":"f64"}],"output":{"name":"f64"}}],[11,"force","","Get the norm of the force for this pair interaction at the distance `r`.",22,{"inputs":[{"name":"self"},{"name":"f64"}],"output":{"name":"f64"}}],[11,"virial","","Get the virial contribution for this pair interaction at the distance `r`.",22,{"inputs":[{"name":"self"},{"name":"vector3d"}],"output":{"name":"matrix3"}}],[11,"tail_energy","","Get the tail correction to the energy for this pair interaction",22,{"inputs":[{"name":"self"}],"output":{"name":"f64"}}],[11,"tail_virial","","Get the tail correction to the virial for this pair interaction",22,{"inputs":[{"name":"self"}],"output":{"name":"matrix3"}}],[8,"Potential","","A potential for force and energy computations.",null,null],[10,"energy","","Get the energy corresponding to the variable `x`",23,{"inputs":[{"name":"self"},{"name":"f64"}],"output":{"name":"f64"}}],[10,"force","","Get the force norm corresponding to the variable `x`",23,{"inputs":[{"name":"self"},{"name":"f64"}],"output":{"name":"f64"}}],[8,"PairPotential","","Marker trait for potentials that can be used for non-bonded two body interactions.",null,null],[11,"virial","","Compute the virial contribution corresponding to the distance `r` between the particles.",24,{"inputs":[{"name":"self"},{"name":"vector3d"}],"output":{"name":"matrix3"}}],[10,"tail_energy","","Compute the tail correction to the energy for the given cutoff.",24,{"inputs":[{"name":"self"},{"name":"f64"}],"output":{"name":"f64"}}],[10,"tail_virial","","Compute the tail correction to the virial for the given cutoff.",24,{"inputs":[{"name":"self"},{"name":"f64"}],"output":{"name":"f64"}}],[8,"BondPotential","","Marker trait for potentials that can be used for molecular bonds.",null,null],[11,"virial","","Compute the virial contribution corresponding to the distance `r` between the particles.",25,{"inputs":[{"name":"self"},{"name":"vector3d"}],"output":{"name":"matrix3"}}],[8,"AnglePotential","","Marker trait for potentials that can be used for molecular angles.",null,null],[8,"DihedralPotential","","Marker trait for potentials that can be used for molecular dihedral angles.",null,null],[8,"Computation","","Alternative energy and forces computation.",null,null],[10,"compute_energy","","Compute the energy value at `r`",26,{"inputs":[{"name":"self"},{"name":"f64"}],"output":{"name":"f64"}}],[10,"compute_force","","Compute the force value at `r`",26,{"inputs":[{"name":"self"},{"name":"f64"}],"output":{"name":"f64"}}],[8,"GlobalPotential","","A potential acting on the whole [System][System] at once.",null,null],[10,"cutoff","","Return the cut off radius.",27,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[10,"energy","","Compute the energetic contribution of this potential",27,{"inputs":[{"name":"self"},{"name":"configuration"}],"output":{"name":"f64"}}],[10,"forces","","Compute the force contribution of this potential. This function should return a vector containing the force acting on each particle in the configuration.",27,null],[10,"virial","","Compute the total virial contribution of this potential",27,{"inputs":[{"name":"self"},{"name":"configuration"}],"output":{"name":"matrix3"}}],[8,"GlobalCache","","Energetic cache for global potentials.",null,null],[10,"move_particles_cost","","Get the cost of moving particles in the system.",28,null],[10,"update","","Update the cache as needed after a call to `move_particles_cost`.",28,{"inputs":[{"name":"self"}],"output":null}],[8,"CoulombicPotential","","Electrostatic potential solver.",null,null],[10,"set_restriction","","Set the pair restriction scheme to use to the given `restriction`. All future call to `GlobalPotential::energy`, `GlobalPotential::force` or `GlobalPotential::virial` should use this restriction.",29,{"inputs":[{"name":"self"},{"name":"pairrestriction"}],"output":null}],[0,"sys","lumol","The `system` module provide a way to store data about a simulated system.",null,null],[3,"PeriodicTable","lumol::sys","The `PeriodicTable` struct give access to elements information, and give a way to register new elements in the list.",null,null],[3,"ElementData","","Data about one \"extended\" chemical element.",null,null],[12,"symbol","","The symbol is used to identify the element",30,null],[12,"name","","The element full name",30,null],[12,"mass","","The element mass, in internal units",30,null],[12,"covalent","","The covalent radius, in internal units",30,null],[12,"vdw","","The Van der Waals radius, in internal units",30,null],[3,"Particle","","The Particle type hold basic data about a particle in the system. It is self contained, so that it will be easy to send data between parallels processes.",null,null],[12,"mass","","Particle mass",31,null],[12,"charge","","Particle charge",31,null],[12,"position","","Particle positions",31,null],[12,"velocity","","Particle velocity, if needed",31,null],[3,"ParticleKind","","A particle kind. Particles with the same name will have the same kind. This is used for faster potential lookup.",null,null],[12,"0","","",32,null],[3,"Composition","","The system composition contains the number of particles of each kind in the system.",null,null],[3,"UnitCell","","An UnitCell defines the system physical boundaries.",null,null],[3,"Bond","","A `Bond` between the particles at indexes `i` and `j`",null,null],[3,"Angle","","An `Angle` formed by the particles at indexes `i`, `j` and `k`",null,null],[3,"Dihedral","","A `Dihedral` angle formed by the particles at indexes `i`, `j`, `k` and `m`",null,null],[3,"BondDistance","","The `BondDistance` bitflag encode the topological distance between two particles in the molecule, i.e. the number of bonds between the particles.",null,null],[3,"Molecule","","A molecule is the basic building block for a topology. It contains data about the connectivity (bonds, angles, dihedrals) in the system.",null,null],[3,"Configuration","","The `Configuration` contains the physical data of the system:",null,null],[12,"cell","","Unit cell of the system",33,null],[3,"System","","The `System` type hold all the data about a simulated system.",null,null],[3,"EnergyEvaluator","","An helper struct to evaluate energy components of a system.",null,null],[3,"EnergyCache","","This is a cache for energy computation.",null,null],[3,"Trajectory","","A Trajectory is a file containing one or more successive simulation steps.",null,null],[3,"TrajectoryError","","Possible error when reading and writing to trajectories",null,null],[3,"TrajectoryBuilder","","A `Trajectory` builder, to set some options before opening a trajectory.",null,null],[4,"CellShape","","The shape of a cell determine how we will be able to compute the periodic boundaries condition.",null,null],[13,"Infinite","","Infinite unit cell, with no boundaries",34,null],[13,"Orthorhombic","","Orthorhombic unit cell, with cuboid shape",34,null],[13,"Triclinic","","Triclinic unit cell, with arbitrary parallelepipedic shape",34,null],[4,"OpenMode","","Possible modes when opening a `Trajectory`.",null,null],[13,"Read","","Open the file as read-only",35,null],[13,"Write","","Open the file as write-only, and overwrite any existing file",35,null],[13,"Append","","Open the file as read-write, keeping existing files",35,null],[5,"molecule_type","","Get the molecule type of the given `molecule` containing the `particles`. This type can be used to identify all the molecules containing the same bonds and particles (see `System::molecule_type` for more information).",null,null],[5,"read_molecule","","Read a the first molecule from the file at `path`. If no bond information exists in the file, bonds are guessed.",null,{"inputs":[{"name":"p"}],"output":{"name":"result"}}],[11,"add_element","","Add a new element in the elements list. The additional list is searched before the `PERIODIC_TABLE` array, so adding a new element here will make it overwrite the real one.",36,{"inputs":[{"name":"elementdata"}],"output":null}],[11,"name","","Get the name of an element from it's symbol.",36,{"inputs":[{"name":"s"}],"output":{"name":"option"}}],[11,"mass","","Get the mass of an element from it's symbol.",36,{"inputs":[{"name":"s"}],"output":{"name":"option"}}],[11,"covalent","","Get the covalent radius of an element from it's symbol.",36,{"inputs":[{"name":"s"}],"output":{"name":"option"}}],[11,"vdw","","Get the Van der Waals radius of an element from it's symbol.",36,{"inputs":[{"name":"s"}],"output":{"name":"option"}}],[11,"clone","","",32,{"inputs":[{"name":"self"}],"output":{"name":"particlekind"}}],[11,"hash","","",32,null],[11,"partial_cmp","","",32,{"inputs":[{"name":"self"},{"name":"particlekind"}],"output":{"name":"option"}}],[11,"lt","","",32,{"inputs":[{"name":"self"},{"name":"particlekind"}],"output":{"name":"bool"}}],[11,"le","","",32,{"inputs":[{"name":"self"},{"name":"particlekind"}],"output":{"name":"bool"}}],[11,"gt","","",32,{"inputs":[{"name":"self"},{"name":"particlekind"}],"output":{"name":"bool"}}],[11,"ge","","",32,{"inputs":[{"name":"self"},{"name":"particlekind"}],"output":{"name":"bool"}}],[11,"cmp","","",32,{"inputs":[{"name":"self"},{"name":"particlekind"}],"output":{"name":"ordering"}}],[11,"eq","","",32,{"inputs":[{"name":"self"},{"name":"particlekind"}],"output":{"name":"bool"}}],[11,"ne","","",32,{"inputs":[{"name":"self"},{"name":"particlekind"}],"output":{"name":"bool"}}],[11,"fmt","","",32,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"invalid","","Get an invalid value (`u32::max_value()`) to use as a marker",32,{"inputs":[],"output":{"name":"particlekind"}}],[11,"fmt","","",32,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",31,{"inputs":[{"name":"self"}],"output":{"name":"particle"}}],[11,"fmt","","",31,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Create a new `Particle` from a `name`",31,{"inputs":[{"name":"s"}],"output":{"name":"particle"}}],[11,"with_position","","Create a new `Particle` from a `name` and a `position`",31,{"inputs":[{"name":"s"},{"name":"vector3d"}],"output":{"name":"particle"}}],[11,"name","","Get the particle name",31,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"set_name","","Set the particle name to `name`",31,{"inputs":[{"name":"self"},{"name":"s"}],"output":null}],[11,"clone","","",37,{"inputs":[{"name":"self"}],"output":{"name":"composition"}}],[11,"fmt","","",37,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",37,{"inputs":[{"name":"self"},{"name":"composition"}],"output":{"name":"bool"}}],[11,"ne","","",37,{"inputs":[{"name":"self"},{"name":"composition"}],"output":{"name":"bool"}}],[11,"new","","Create a new empty composition",37,{"inputs":[],"output":{"name":"composition"}}],[11,"len","","Get the size of the composition, i.e. the number of different particle kinds in the composition.",37,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"is_empty","","Check if the composition is empty, i.e. if it contains no particle kind. A composition with only zero entries (`0 => 0, 2 => 0, 3 => 0`) is not empty.",37,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"resize","","Resize the composition to hold `size` items. The new particles kinds start with no associated particles.",37,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"index","","",37,{"inputs":[{"name":"self"},{"name":"particlekind"}],"output":{"name":"usize"}}],[11,"index_mut","","",37,{"inputs":[{"name":"self"},{"name":"particlekind"}],"output":{"name":"usize"}}],[11,"fmt","","",34,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",34,{"inputs":[{"name":"self"}],"output":{"name":"cellshape"}}],[11,"eq","","",34,{"inputs":[{"name":"self"},{"name":"cellshape"}],"output":{"name":"bool"}}],[11,"fmt","","",38,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",38,{"inputs":[{"name":"self"}],"output":{"name":"unitcell"}}],[11,"eq","","",38,{"inputs":[{"name":"self"},{"name":"unitcell"}],"output":{"name":"bool"}}],[11,"ne","","",38,{"inputs":[{"name":"self"},{"name":"unitcell"}],"output":{"name":"bool"}}],[11,"new","","Create an infinite unit cell",38,{"inputs":[],"output":{"name":"unitcell"}}],[11,"ortho","","Create an orthorhombic unit cell, with side lengths `a, b, c`.",38,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"unitcell"}}],[11,"cubic","","Create a cubic unit cell, with side lengths `length, length, length`.",38,{"inputs":[{"name":"f64"}],"output":{"name":"unitcell"}}],[11,"triclinic","","Create a triclinic unit cell, with side lengths `a, b, c` and angles `alpha, beta, gamma`.",38,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"unitcell"}}],[11,"shape","","Get the cell shape",38,{"inputs":[{"name":"self"}],"output":{"name":"cellshape"}}],[11,"is_infinite","","Check if this unit cell is infinite, i.e. if it does not have periodic boundary conditions.",38,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"vect_a","","Get the first vector of the cell",38,{"inputs":[{"name":"self"}],"output":{"name":"vector3d"}}],[11,"a","","Get the first length of the cell (i.e. the norm of the first vector of the cell)",38,{"inputs":[{"name":"self"}],"output":{"name":"f64"}}],[11,"vect_b","","Get the second vector of the cell",38,{"inputs":[{"name":"self"}],"output":{"name":"vector3d"}}],[11,"b","","Get the second length of the cell (i.e. the norm of the second vector of the cell)",38,{"inputs":[{"name":"self"}],"output":{"name":"f64"}}],[11,"vect_c","","Get the third vector of the cell",38,{"inputs":[{"name":"self"}],"output":{"name":"vector3d"}}],[11,"c","","Get the third length of the cell (i.e. the norm of the third vector of the cell)",38,{"inputs":[{"name":"self"}],"output":{"name":"f64"}}],[11,"lengths","","Get the distances between faces of the unit cell",38,null],[11,"alpha","","Get the first angle of the cell",38,{"inputs":[{"name":"self"}],"output":{"name":"f64"}}],[11,"beta","","Get the second angle of the cell",38,{"inputs":[{"name":"self"}],"output":{"name":"f64"}}],[11,"gamma","","Get the third angle of the cell",38,{"inputs":[{"name":"self"}],"output":{"name":"f64"}}],[11,"volume","","Get the volume of the cell",38,{"inputs":[{"name":"self"}],"output":{"name":"f64"}}],[11,"scale_mut","","Scale this unit cell in-place by multiplying the cell matrix by `factor`.",38,{"inputs":[{"name":"self"},{"name":"matrix3"}],"output":null}],[11,"scale","","Scale this unit cell by multiplying the cell matrix by `s`, and return a new scaled unit cell",38,{"inputs":[{"name":"self"},{"name":"matrix3"}],"output":{"name":"unitcell"}}],[11,"reciprocal_vectors","","Get the reciprocal vectors of this unit cell",38,null],[11,"wrap_vector","","Wrap a vector in the unit cell, obeying the periodic boundary conditions. For a cubic cell of side length `L`, this produce a vector with all components in `[0, L)`.",38,{"inputs":[{"name":"self"},{"name":"vector3d"}],"output":null}],[11,"vector_image","","Find the image of a vector in the unit cell, obeying the periodic boundary conditions. For a cubic cell of side length `L`, this produce a vector with all components in `[-L/2, L/2)`.",38,{"inputs":[{"name":"self"},{"name":"vector3d"}],"output":null}],[11,"fractional","","Get the fractional representation of the `v` vector in this cell",38,{"inputs":[{"name":"self"},{"name":"vector3d"}],"output":{"name":"vector3d"}}],[11,"cartesian","","Get the Cartesian representation of the fractional `v` vector in this cell",38,{"inputs":[{"name":"self"},{"name":"vector3d"}],"output":{"name":"vector3d"}}],[11,"distance","","Periodic boundary conditions distance between the point `u` and the point `v`",38,{"inputs":[{"name":"self"},{"name":"vector3d"},{"name":"vector3d"}],"output":{"name":"f64"}}],[11,"angle","","Get the angle formed by the points at `a`, `b` and `c` using periodic boundary conditions.",38,{"inputs":[{"name":"self"},{"name":"vector3d"},{"name":"vector3d"},{"name":"vector3d"}],"output":{"name":"f64"}}],[11,"angle_and_derivatives","","Get the angle formed by the points at `a`, `b` and `c` using periodic boundary conditions and its derivatives.",38,null],[11,"dihedral","","Get the dihedral angle formed by the points at `a`, `b`, `c`, `d` using periodic boundary conditions.",38,{"inputs":[{"name":"self"},{"name":"vector3d"},{"name":"vector3d"},{"name":"vector3d"},{"name":"vector3d"}],"output":{"name":"f64"}}],[11,"dihedral_and_derivatives","","Get the dihedral angle and and its derivatives defined by the points at `a`, `b`, `c` and `d` using periodic boundary conditions.",38,null],[11,"eq","","",39,{"inputs":[{"name":"self"},{"name":"bonddistance"}],"output":{"name":"bool"}}],[11,"ne","","",39,{"inputs":[{"name":"self"},{"name":"bonddistance"}],"output":{"name":"bool"}}],[11,"clone","","",39,{"inputs":[{"name":"self"}],"output":{"name":"bonddistance"}}],[11,"partial_cmp","","",39,{"inputs":[{"name":"self"},{"name":"bonddistance"}],"output":{"name":"option"}}],[11,"lt","","",39,{"inputs":[{"name":"self"},{"name":"bonddistance"}],"output":{"name":"bool"}}],[11,"le","","",39,{"inputs":[{"name":"self"},{"name":"bonddistance"}],"output":{"name":"bool"}}],[11,"gt","","",39,{"inputs":[{"name":"self"},{"name":"bonddistance"}],"output":{"name":"bool"}}],[11,"ge","","",39,{"inputs":[{"name":"self"},{"name":"bonddistance"}],"output":{"name":"bool"}}],[11,"cmp","","",39,{"inputs":[{"name":"self"},{"name":"bonddistance"}],"output":{"name":"ordering"}}],[11,"hash","","",39,null],[11,"fmt","","",39,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"empty","","Returns an empty set of flags.",39,{"inputs":[],"output":{"name":"bonddistance"}}],[11,"all","","Returns the set containing all flags.",39,{"inputs":[],"output":{"name":"bonddistance"}}],[11,"bits","","Returns the raw value of the flags currently stored.",39,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"from_bits","","Convert from underlying bit representation, unless that representation contains bits that do not correspond to a flag.",39,{"inputs":[{"name":"u8"}],"output":{"name":"option"}}],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits that do not correspond to flags.",39,{"inputs":[{"name":"u8"}],"output":{"name":"bonddistance"}}],[11,"is_empty","","Returns `true` if no flags are currently stored.",39,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_all","","Returns `true` if all flags are currently set.",39,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",39,{"inputs":[{"name":"self"},{"name":"bonddistance"}],"output":{"name":"bool"}}],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",39,{"inputs":[{"name":"self"},{"name":"bonddistance"}],"output":{"name":"bool"}}],[11,"insert","","Inserts the specified flags in-place.",39,{"inputs":[{"name":"self"},{"name":"bonddistance"}],"output":null}],[11,"remove","","Removes the specified flags in-place.",39,{"inputs":[{"name":"self"},{"name":"bonddistance"}],"output":null}],[11,"toggle","","Toggles the specified flags in-place.",39,{"inputs":[{"name":"self"},{"name":"bonddistance"}],"output":null}],[11,"set","","Inserts or removes the specified flags depending on the passed value.",39,{"inputs":[{"name":"self"},{"name":"bonddistance"},{"name":"bool"}],"output":null}],[11,"bitor","","Returns the union of the two sets of flags.",39,{"inputs":[{"name":"self"},{"name":"bonddistance"}],"output":{"name":"bonddistance"}}],[11,"bitor_assign","","Adds the set of flags.",39,{"inputs":[{"name":"self"},{"name":"bonddistance"}],"output":null}],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",39,{"inputs":[{"name":"self"},{"name":"bonddistance"}],"output":{"name":"bonddistance"}}],[11,"bitxor_assign","","Toggles the set of flags.",39,{"inputs":[{"name":"self"},{"name":"bonddistance"}],"output":null}],[11,"bitand","","Returns the intersection between the two sets of flags.",39,{"inputs":[{"name":"self"},{"name":"bonddistance"}],"output":{"name":"bonddistance"}}],[11,"bitand_assign","","Disables all flags disabled in the set.",39,{"inputs":[{"name":"self"},{"name":"bonddistance"}],"output":null}],[11,"sub","","Returns the set difference of the two sets of flags.",39,{"inputs":[{"name":"self"},{"name":"bonddistance"}],"output":{"name":"bonddistance"}}],[11,"sub_assign","","Disables all flags enabled in the set.",39,{"inputs":[{"name":"self"},{"name":"bonddistance"}],"output":null}],[11,"not","","Returns the complement of this set of flags.",39,{"inputs":[{"name":"self"}],"output":{"name":"bonddistance"}}],[11,"extend","","",39,{"inputs":[{"name":"self"},{"name":"t"}],"output":null}],[11,"from_iter","","",39,{"inputs":[{"name":"t"}],"output":{"name":"bonddistance"}}],[11,"default","","",39,{"inputs":[],"output":{"name":"bonddistance"}}],[11,"clone","","",40,{"inputs":[{"name":"self"}],"output":{"name":"bond"}}],[11,"fmt","","",40,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",40,{"inputs":[{"name":"self"},{"name":"bond"}],"output":{"name":"bool"}}],[11,"ne","","",40,{"inputs":[{"name":"self"},{"name":"bond"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",40,{"inputs":[{"name":"self"},{"name":"bond"}],"output":{"name":"option"}}],[11,"lt","","",40,{"inputs":[{"name":"self"},{"name":"bond"}],"output":{"name":"bool"}}],[11,"le","","",40,{"inputs":[{"name":"self"},{"name":"bond"}],"output":{"name":"bool"}}],[11,"gt","","",40,{"inputs":[{"name":"self"},{"name":"bond"}],"output":{"name":"bool"}}],[11,"ge","","",40,{"inputs":[{"name":"self"},{"name":"bond"}],"output":{"name":"bool"}}],[11,"cmp","","",40,{"inputs":[{"name":"self"},{"name":"bond"}],"output":{"name":"ordering"}}],[11,"hash","","",40,null],[11,"new","","Create a new Bond between the particles at indexes `first` and `second`",40,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"bond"}}],[11,"i","","Get the first particle in the bond",40,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"j","","Get the second particle in the bond",40,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"clone","","",41,{"inputs":[{"name":"self"}],"output":{"name":"angle"}}],[11,"fmt","","",41,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",41,{"inputs":[{"name":"self"},{"name":"angle"}],"output":{"name":"bool"}}],[11,"ne","","",41,{"inputs":[{"name":"self"},{"name":"angle"}],"output":{"name":"bool"}}],[11,"hash","","",41,null],[11,"new","","Create a new Angle between the particles at indexes `first`, `second` and `third`",41,{"inputs":[{"name":"usize"},{"name":"usize"},{"name":"usize"}],"output":{"name":"angle"}}],[11,"i","","Get the first particle in the angle",41,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"j","","Get the second particle in the angle",41,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"k","","Get the third particle in the angle",41,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"clone","","",42,{"inputs":[{"name":"self"}],"output":{"name":"dihedral"}}],[11,"fmt","","",42,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",42,{"inputs":[{"name":"self"},{"name":"dihedral"}],"output":{"name":"bool"}}],[11,"ne","","",42,{"inputs":[{"name":"self"},{"name":"dihedral"}],"output":{"name":"bool"}}],[11,"hash","","",42,null],[11,"new","","Create a new Dihedral between the particles at indexes `first`, `second`, `third` and `fourth`",42,{"inputs":[{"name":"usize"},{"name":"usize"},{"name":"usize"},{"name":"usize"}],"output":{"name":"dihedral"}}],[11,"i","","Get the first particle in the dihedral angle",42,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"j","","Get the second particle in the dihedral angle",42,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"k","","Get the third particle in the dihedral angle",42,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"m","","Get the fourth particle in the dihedral angle",42,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"fmt","","",43,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",43,{"inputs":[{"name":"self"}],"output":{"name":"molecule"}}],[11,"hash","","",43,{"inputs":[{"name":"self"},{"name":"h"}],"output":null}],[11,"new","","Create a new `Molecule` containing only the atom i",43,{"inputs":[{"name":"usize"}],"output":{"name":"molecule"}}],[11,"size","","Get the number of atoms in the molecule",43,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"start","","Get the first atom of this molecule",43,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"end","","Get the index of the first atom after this molecule",43,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"contains","","Does this molecule contains the particle `i`",43,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"bool"}}],[11,"merge_with","","Merge this molecule with `other`. The first particle in `other` should be the particle just after the last one in `self`.",43,{"inputs":[{"name":"self"},{"name":"molecule"}],"output":null}],[11,"translate_by","","Translate all indexes in this molecule by `delta`.",43,{"inputs":[{"name":"self"},{"name":"isize"}],"output":null}],[11,"add_bond","","Add a bond between the particles at indexes `i` and `j`. These particles are assumed to be in the molecule",43,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"}],"output":null}],[11,"remove_particle","","Removes particle at index `i` and any associated bonds, angle or dihedral. This function also update the indexes for the bonds/angles/dihedral by remove 1 to all the values `> i`",43,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"bonds","","Get the internal list of bonds",43,{"inputs":[{"name":"self"}],"output":{"name":"hashset"}}],[11,"angles","","Get the internal list of angles",43,{"inputs":[{"name":"self"}],"output":{"name":"hashset"}}],[11,"dihedrals","","Get the internal list of dihedrals",43,{"inputs":[{"name":"self"}],"output":{"name":"hashset"}}],[11,"bond_distance","","Get the bond distance between the particles `i` and `j`",43,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"}],"output":{"name":"bonddistance"}}],[11,"iter","","Get an iterator over the particles in the molecule",43,{"inputs":[{"name":"self"}],"output":{"name":"range"}}],[11,"into_iter","","",43,{"inputs":[{"name":"self"}],"output":{"name":"range"}}],[11,"clone","","",33,{"inputs":[{"name":"self"}],"output":{"name":"configuration"}}],[11,"new","","Create a new empty `Configuration`",33,{"inputs":[],"output":{"name":"configuration"}}],[11,"molecule_type","","Get the type of the molecule at index `molid`. This type is a hash of the atoms names, and the set of bonds in the molecule. This means that two molecules will have the same type if and only if they contains the same atoms and the same bonds, in the same order.",33,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"u64"}}],[11,"molecules_with_moltype","","Get a list of molecules with `moltype` molecule type.",33,{"inputs":[{"name":"self"},{"name":"u64"}],"output":{"name":"vec"}}],[11,"are_in_same_molecule","","Check if the particles at indexes `i` and `j` are in the same molecule",33,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"}],"output":{"name":"bool"}}],[11,"molecules","","Get the list of molecules in the configuration.",33,null],[11,"molecule","","Get the molecule at index `id`",33,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"molecule"}}],[11,"molid","","Get the index of the molecule containing the particle `i`",33,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"usize"}}],[11,"bond_distance","","Get the length of the shortest bond path to go from the particle `i` to the particle `j`. If the particles are not in the same molecule, the length is -1. Else, this length is 0 if `i == j`, 1 if there is a bond between `i` and `j`, etc.",33,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"}],"output":{"name":"i8"}}],[11,"remove_molecule","","Remove the molecule at index `i`",33,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"add_bond","","Add a bond between the particles at indexes `i` and `j`. The particles should have been added to the configuration before calling this.",33,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"}],"output":{"name":"vec"}}],[11,"remove_particle","","Removes particle at index `i` and any associated bonds, angle or dihedral",33,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"add_particle","","Insert a particle at the end of the internal list. The new particle must have a valid particle kind.",33,{"inputs":[{"name":"self"},{"name":"particle"}],"output":null}],[11,"size","","Get the number of particles in this configuration",33,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"is_empty","","Check if this configuration contains any particle",33,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"molecule_com","","Return the center-of-mass of a molecule",33,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"vector3d"}}],[11,"center_of_mass","","Return the center-of-mass of the configuration",33,{"inputs":[{"name":"self"}],"output":{"name":"vector3d"}}],[11,"wrap_molecule","","Move all particles of a molecule such that the molecules center-of-mass position resides inside the simulation cell.",33,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"particles","","Get an iterator over the `Particle` in this configuration",33,{"inputs":[{"name":"self"}],"output":{"name":"iter"}}],[11,"particles_mut","","Get a mutable iterator over the `Particle` in this configuration",33,{"inputs":[{"name":"self"}],"output":{"name":"itermut"}}],[11,"particle","","Get a reference to the `i`'th particle in this configuration",33,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"particle"}}],[11,"particle_mut","","Get a mutable reference to the `i`'th particle in this configuration",33,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"particle"}}],[11,"distance","","Get the distance between the particles at indexes `i` and `j`",33,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"}],"output":{"name":"f64"}}],[11,"nearest_image","","Get the vector between the nearest image of particle `j` with respect to particle `i`.",33,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"}],"output":{"name":"vector3d"}}],[11,"angle","","Get the angle between the particles `i`, `j` and `k`",33,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"},{"name":"usize"}],"output":{"name":"f64"}}],[11,"angle_and_derivatives","","Get the angle and the derivatives of the angle between the particles `i`, `j` and `k`",33,null],[11,"dihedral","","Get the dihedral angle between the particles `i`, `j`, `k` and `m`",33,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"},{"name":"usize"},{"name":"usize"}],"output":{"name":"f64"}}],[11,"dihedral_and_derivatives","","Get the dihedral angle and the derivatives of the dihedral angle between the particles `i`, `j`, `k` and `m`",33,null],[11,"clone","","",44,{"inputs":[{"name":"self"}],"output":{"name":"system"}}],[11,"new","","Create a new empty `System`",44,{"inputs":[],"output":{"name":"system"}}],[11,"with_cell","","Create an empty system with a specific unit cell",44,{"inputs":[{"name":"unitcell"}],"output":{"name":"system"}}],[11,"add_particle","","Insert a particle at the end of the internal list.",44,{"inputs":[{"name":"self"},{"name":"particle"}],"output":null}],[11,"composition","","Get the number of particles of each kind in the configuration",44,{"inputs":[{"name":"self"}],"output":{"name":"composition"}}],[11,"particle_kinds","","Get a list of all the particles kinds in the system.",44,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[11,"step","","Get the current step of the system",44,{"inputs":[{"name":"self"}],"output":{"name":"u64"}}],[11,"increment_step","","Increment the system step",44,{"inputs":[{"name":"self"}],"output":null}],[11,"external_temperature","","Use an external temperature for all the system properties. Calling this with `Some(temperature)` will replace all the computation of the temperature from the velocities with the given values. Calling it with `None` will use the velocities.",44,{"inputs":[{"name":"self"},{"name":"option"}],"output":null}],[11,"guess_bonds","","Guess the bonds in the configuration using the chemfiles algorithm.",44,{"inputs":[{"name":"self"}],"output":null}],[11,"energy_evaluator","","Get an helper struct to evaluate the energy of this system.",44,{"inputs":[{"name":"self"}],"output":{"name":"energyevaluator"}}],[11,"add_pair_potential","","Add the `potential` pair interaction for the pair `(i, j)`",44,{"inputs":[{"name":"self"},{"name":"str"},{"name":"str"},{"name":"pairinteraction"}],"output":null}],[11,"add_bond_potential","","Add the `potential` bonded interaction for the pair `(i, j)`",44,{"inputs":[{"name":"self"},{"name":"str"},{"name":"str"},{"name":"box"}],"output":null}],[11,"add_angle_potential","","Add the `potential` angle interaction for the angle `(i, j, k)`",44,{"inputs":[{"name":"self"},{"name":"str"},{"name":"str"},{"name":"str"},{"name":"box"}],"output":null}],[11,"add_dihedral_potential","","Add the `potential` dihedral interaction for the dihedral angle `(i, j, k, m)`",44,{"inputs":[{"name":"self"},{"name":"str"},{"name":"str"},{"name":"str"},{"name":"str"},{"name":"box"}],"output":null}],[11,"set_coulomb_potential","","Set the coulombic interaction for all pairs to `potential`",44,{"inputs":[{"name":"self"},{"name":"box"}],"output":null}],[11,"add_global_potential","","Add the `potential` global interaction",44,{"inputs":[{"name":"self"},{"name":"box"}],"output":null}],[11,"pair_potentials","","Get the list of pair potential acting between the particles at indexes `i` and `j`.",44,null],[11,"bond_potentials","","Get the list of bonded potential acting between the particles at indexes `i` and `j`.",44,null],[11,"angle_potentials","","Get the list of angle interaction acting between the particles at indexes `i`, `j` and `k`.",44,null],[11,"dihedral_potentials","","Get the list of dihedral angles interaction acting between the particles at indexes `i`, `j`, `k` and `m`.",44,null],[11,"coulomb_potential","","Get the coulombic interaction for the system",44,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"global_potentials","","Get all global interactions for the system",44,null],[11,"maximum_cutoff","","Get maximum cutoff from `coulomb`, `pairs` and `global` interactions.",44,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"kinetic_energy","","Get the kinetic energy of the system.",44,{"inputs":[{"name":"self"}],"output":{"name":"f64"}}],[11,"potential_energy","","Get the potential energy of the system.",44,{"inputs":[{"name":"self"}],"output":{"name":"f64"}}],[11,"total_energy","","Get the total energy of the system.",44,{"inputs":[{"name":"self"}],"output":{"name":"f64"}}],[11,"temperature","","Get the temperature of the system.",44,{"inputs":[{"name":"self"}],"output":{"name":"f64"}}],[11,"volume","","Get the volume of the system.",44,{"inputs":[{"name":"self"}],"output":{"name":"f64"}}],[11,"virial","","Get the virial of the system as a tensor",44,{"inputs":[{"name":"self"}],"output":{"name":"matrix3"}}],[11,"pressure","","Get the pressure of the system from the virial equation, at the system instantaneous temperature.",44,{"inputs":[{"name":"self"}],"output":{"name":"f64"}}],[11,"stress","","Get the stress tensor of the system from the virial equation.",44,{"inputs":[{"name":"self"}],"output":{"name":"matrix3"}}],[11,"forces","","Get the forces acting on all the particles in the system",44,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[11,"deref","","",44,{"inputs":[{"name":"self"}],"output":{"name":"configuration"}}],[11,"deref_mut","","",44,{"inputs":[{"name":"self"}],"output":{"name":"configuration"}}],[11,"new","","Create a new `EnergyEvaluator` acting on the given `system`.",45,{"inputs":[{"name":"system"}],"output":{"name":"energyevaluator"}}],[11,"pair","","Compute the energy associated with the pair of particles `i, j` at distance `r`",45,{"inputs":[{"name":"self"},{"name":"f64"},{"name":"usize"},{"name":"usize"}],"output":{"name":"f64"}}],[11,"pairs","","Compute the energy of all the pairs in the system",45,{"inputs":[{"name":"self"}],"output":{"name":"f64"}}],[11,"pairs_tail","","Compute the energy due to long range corrections for the pairs",45,{"inputs":[{"name":"self"}],"output":{"name":"f64"}}],[11,"bond","","Compute the energy associated with the bonded particles `i, j` at distance `r`",45,{"inputs":[{"name":"self"},{"name":"f64"},{"name":"usize"},{"name":"usize"}],"output":{"name":"f64"}}],[11,"bonds","","Compute the energy of all the bonds in the system",45,{"inputs":[{"name":"self"}],"output":{"name":"f64"}}],[11,"angle","","Compute the energy associated with the angle `i, j, k` at angle `theta`",45,{"inputs":[{"name":"self"},{"name":"f64"},{"name":"usize"},{"name":"usize"},{"name":"usize"}],"output":{"name":"f64"}}],[11,"angles","","Compute the energy of all the angles in the system",45,{"inputs":[{"name":"self"}],"output":{"name":"f64"}}],[11,"dihedral","","Compute the energy associated with the dihedral angle `i, j, k, m` at angle `phi`",45,{"inputs":[{"name":"self"},{"name":"f64"},{"name":"usize"},{"name":"usize"},{"name":"usize"},{"name":"usize"}],"output":{"name":"f64"}}],[11,"dihedrals","","Compute the energy of all the dihedral angles in the system",45,{"inputs":[{"name":"self"}],"output":{"name":"f64"}}],[11,"coulomb","","Compute the energy of the electrostatic interactions",45,{"inputs":[{"name":"self"}],"output":{"name":"f64"}}],[11,"global","","Compute the energy of the global potentials",45,{"inputs":[{"name":"self"}],"output":{"name":"f64"}}],[11,"new","","Create a new empty energy cache.",46,{"inputs":[],"output":{"name":"energycache"}}],[11,"init","","Initialize the cache to be used with `system`. After a call to this function, the cache is only usable with the same system. To change the associated system, one must call this function again.",46,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[11,"energy","","Get the cached energy",46,{"inputs":[{"name":"self"}],"output":{"name":"f64"}}],[11,"update","","Update the cache after a call to a `EnergyCache::*_cost` function or `EnergyCache::unused`.",46,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[11,"unused","","This function should be called whenever the cache is not used, but one still want it to be updated. Future call to `EnergyCache::update` will recompute the full cache.",46,{"inputs":[{"name":"self"}],"output":null}],[11,"move_particles_cost","","Get the cost of moving the set of particles with indexes in `idxes` to `newpos`.",46,null],[11,"move_all_rigid_molecules_cost","","Return the cost for moving all rigid molecules of the system.",46,{"inputs":[{"name":"self"},{"name":"system"}],"output":{"name":"f64"}}],[11,"fmt","","",47,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",47,{"inputs":[{"name":"error"}],"output":{"name":"trajectoryerror"}}],[11,"fmt","","",47,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","",47,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"new","","Create a new builder in read mode and with automatic format detection.",48,{"inputs":[],"output":{"name":"trajectorybuilder"}}],[11,"format","","Use a specific `format` when opening a file. See the [chemfiles] documentation for a format list.",48,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"trajectorybuilder"}}],[11,"mode","","Use a specific `mode` when opening a file.",48,{"inputs":[{"name":"self"},{"name":"openmode"}],"output":{"name":"trajectorybuilder"}}],[11,"open","","Open the trajectory at the given `path`.",48,{"inputs":[{"name":"self"},{"name":"p"}],"output":{"name":"result"}}],[11,"read","","Read the next step of the trajectory",49,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"read_guess_bonds","","Read the next step of the trajectory, and guess the bonds of the resulting [`System`][struct.System.html].",49,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"write","","Write the system to the trajectory.",49,{"inputs":[{"name":"self"},{"name":"system"}],"output":{"name":"result"}}],[11,"set_cell","","Set the unit cell associated with a trajectory. This cell will be used when reading and writing the files, replacing any unit cell in the frames or files.",49,{"inputs":[{"name":"self"},{"name":"unitcell"}],"output":{"name":"result"}}],[11,"set_topology_file","","Set the topology associated with this trajectory by reading the first frame of the file at the given `path` and extracting the topology of this frame. This topology will be used to replace any existing topology when reading or writing with this trajectory.",49,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"result"}}],[0,"veloc","","This module provides some ways to initialize the velocities in a `System`",null,null],[3,"BoltzmannVelocities","lumol::sys::veloc","Initialize the velocities from a Boltzmann distribution.",null,null],[3,"UniformVelocities","","Initialize the velocities from an uniform distribution.",null,null],[5,"scale","","Scale all velocities in the `System` such that the `system` temperature is `temperature`.",null,{"inputs":[{"name":"system"},{"name":"f64"}],"output":null}],[8,"InitVelocities","","A method to initialize the velocities of a system.",null,null],[10,"init","","Initialize the velocities of the system.",50,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[10,"seed","","Set the seed of the random number generator. The default seed is 42.",50,{"inputs":[{"name":"self"},{"name":"u64"}],"output":null}],[11,"new","","Create a new `BoltzmannVelocities` at the given `temperature`.",51,{"inputs":[{"name":"f64"}],"output":{"name":"boltzmannvelocities"}}],[11,"init","","",51,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[11,"seed","","",51,{"inputs":[{"name":"self"},{"name":"u64"}],"output":null}],[11,"new","","Create a new `UniformVelocities` at the given `temperature`.",52,{"inputs":[{"name":"f64"}],"output":{"name":"uniformvelocities"}}],[11,"init","","",52,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[11,"seed","","",52,{"inputs":[{"name":"self"},{"name":"u64"}],"output":null}],[0,"compute","lumol::sys","Computing properties of a system",null,null],[3,"Forces","lumol::sys::compute","Compute all the forces acting on the system, and return a vector of force acting on each particles",null,null],[3,"PotentialEnergy","","Compute the potential energy of the system",null,null],[3,"KineticEnergy","","Compute the kinetic energy of the system",null,null],[3,"TotalEnergy","","Compute the total energy of the system",null,null],[3,"Temperature","","Compute the instantaneous temperature of the system",null,null],[3,"Volume","","Compute the volume of the system",null,null],[3,"Virial","","Compute the virial tensor of the system, defined by $$ W = \\sum_i \\sum_{j > i} \\vec r_{ij} \\otimes \\vec f_{ij} $$",null,null],[3,"PressureAtTemperature","","Compute the pressure of the system from the virial equation, at the given temperature. This pressure is given by the following formula: $$ p = \\frac{N k_B T}{V} + \\frac{1}{3V} \\sum_i \\vec f_i \\cdot \\vec r_i $$",null,null],[12,"temperature","","Temperature for the pressure computation",53,null],[3,"StressAtTemperature","","Compute the stress tensor of the system from the virial equation, at the given temperature. The stress tensor is defined by $$ \\sigma = \\sigma = \\frac{1}{V} (\\sum_i m_i v_i \\otimes v_i + \\sum_i \\sum_{j > i} \\vec r_{ij} \\otimes \\vec f_{ij}) $$ but here the kinetic energy term is replaced by it average at the given temperature.",null,null],[12,"temperature","","Temperature for the stress tensor computation",54,null],[3,"Stress","","Compute the stress tensor of the system, defined by: $$ \\sigma = \\frac{1}{V} (\\sum_i m_i v_i \\otimes v_i + \\sum_i \\sum_{j > i} \\vec r_{ij} \\otimes \\vec f_{ij}) $$",null,null],[3,"Pressure","","Compute the virial pressure of the system. This pressure is given by the following formula: $$ p = \\frac{N k_B T}{V} + \\frac{1}{3V} \\sum_i \\vec f_i \\cdot \\vec r_i $$",null,null],[8,"Compute","","The compute trait allow to compute properties of a system, without modifying this system. The Output type is the type of the computed property.",null,null],[16,"Output","","The data type of the property",55,null],[10,"compute","","Compute the property",55,null],[11,"compute","","",56,{"inputs":[{"name":"self"},{"name":"system"}],"output":{"name":"vec"}}],[11,"compute","","",57,{"inputs":[{"name":"self"},{"name":"system"}],"output":{"name":"f64"}}],[11,"compute","","",58,{"inputs":[{"name":"self"},{"name":"system"}],"output":{"name":"f64"}}],[11,"compute","","",59,{"inputs":[{"name":"self"},{"name":"system"}],"output":{"name":"f64"}}],[11,"compute","","",60,{"inputs":[{"name":"self"},{"name":"system"}],"output":{"name":"f64"}}],[11,"compute","","",61,{"inputs":[{"name":"self"},{"name":"system"}],"output":{"name":"f64"}}],[11,"compute","","",62,{"inputs":[{"name":"self"},{"name":"system"}],"output":{"name":"matrix3"}}],[11,"compute","","",53,{"inputs":[{"name":"self"},{"name":"system"}],"output":{"name":"f64"}}],[11,"compute","","",54,{"inputs":[{"name":"self"},{"name":"system"}],"output":{"name":"matrix3"}}],[11,"compute","","",63,{"inputs":[{"name":"self"},{"name":"system"}],"output":{"name":"matrix3"}}],[11,"compute","","",64,{"inputs":[{"name":"self"},{"name":"system"}],"output":{"name":"f64"}}],[17,"BONDED_12","lumol::sys","The particles are separated by one bond",null,null],[17,"BONDED_13","","The particles are separated by two bonds",null,null],[17,"BONDED_14","","The particles are separated by three bonds",null,null],[17,"BONDED_FAR","","The particles are separated by more than three bonds",null,null],[0,"sim","lumol","Types and traits for representing simulation algorithms",null,null],[3,"Simulation","lumol::sim","The Simulation struct holds all the needed algorithms for running the simulation. It should be use together with a `System` to perform the simulation.",null,null],[3,"MolecularDynamics","","Molecular Dynamics propagator for the simulation.",null,null],[3,"MonteCarlo","","Metropolis Monte Carlo propagator",null,null],[3,"Minimization","","Minimization propagator for simulations.",null,null],[3,"Alternator","","Helper struct that can wrap an algorithm to make it run only a fraction of the times it is called.",null,null],[4,"TemperatureStrategy","","Possible temperature computation strategies. Different propagators needs different ways to compute the temperature: Monte Carlo temperature is a constant of the simulation, whereas for molecular dynamics we use the instantaneous velocities.",null,null],[13,"None","","No specific strategy, use whatever strategy was already in use.",65,null],[13,"Velocities","","Use the instantaneous velocities to compute the temperature",65,null],[13,"External","","Use a fixed external temperature",65,null],[0,"md","","Molecular dynamics algorithms.",null,null],[3,"VelocityVerlet","lumol::sim::md","Velocity-Verlet integrator. This one is reversible and symplectic.",null,null],[3,"Verlet","","Verlet integrator. This one is reversible and symplectic.",null,null],[3,"LeapFrog","","Leap-frog integrator. This one is reversible and symplectic.",null,null],[3,"BerendsenBarostat","","Berendsen barostat integrator based on velocity-Verlet. This one neither reversible nor symplectic.",null,null],[3,"AnisoBerendsenBarostat","","Anisotropic Berendsen barostat integrator based on velocity-Verlet. This one neither reversible nor symplectic.",null,null],[3,"RescaleThermostat","","Velocity rescaling thermostat.",null,null],[3,"BerendsenThermostat","","Berendsen thermostat.",null,null],[3,"RemoveTranslation","","Remove global translation from the system",null,null],[3,"RemoveRotation","","Remove global rotation from the system",null,null],[3,"MolecularDynamics","","Molecular Dynamics propagator for the simulation.",null,null],[11,"new","","Create a new integrator with a timestep of `timestep`.",66,{"inputs":[{"name":"f64"}],"output":{"name":"velocityverlet"}}],[11,"setup","","",66,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[11,"integrate","","",66,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[11,"new","","Create a new integrator with a timestep of `timestep`.",67,{"inputs":[{"name":"f64"}],"output":{"name":"verlet"}}],[11,"setup","","",67,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[11,"integrate","","",67,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[11,"new","","Create a new integrator with a timestep of `timestep`.",68,{"inputs":[{"name":"f64"}],"output":{"name":"leapfrog"}}],[11,"setup","","",68,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[11,"integrate","","",68,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[11,"new","","Create a new Berendsen barostat with an integration timestep of `timestep`, and a target pressure of `pressure` and the barostat time scale `tau`.",69,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"berendsenbarostat"}}],[11,"setup","","",69,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[11,"integrate","","",69,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[11,"new","","Create a new anisotropic Berendsen barostat with an integration timestep of `timestep`, and a target stress matrix of `stress` and the barostat time scale `tau`.",70,{"inputs":[{"name":"f64"},{"name":"matrix3"},{"name":"f64"}],"output":{"name":"anisoberendsenbarostat"}}],[11,"hydrostatic","","Create a new anisotropic Berendsen barostat with an integration timestep of `timestep`, using an hydrostatic stress matrix corresponding to the pressure `pressure` and the barostat time scale `tau`.",70,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"anisoberendsenbarostat"}}],[11,"setup","","",70,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[11,"integrate","","",70,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[11,"new","","Create a new `RescaleThermostat` acting at temperature `temperature`, with a tolerance of `5% * temperature`.",71,{"inputs":[{"name":"f64"}],"output":{"name":"rescalethermostat"}}],[11,"with_tolerance","","Create a new `RescaleThermostat` acting at temperature `T`, with a tolerance of `tol`. For rescaling all the steps, use `tol = 0`.",71,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"rescalethermostat"}}],[11,"control","","",71,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[11,"new","","Create a new `BerendsenThermostat` acting at temperature `T`, with a timestep of `tau` times the integrator timestep.",72,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"berendsenthermostat"}}],[11,"control","","",72,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[11,"control","lumol::sim","",73,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[11,"new","lumol::sim::md","Create a new `RemoveTranslation` control.",74,{"inputs":[],"output":{"name":"removetranslation"}}],[11,"control","","",74,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[11,"new","","Create a new `RemoveRotation` control.",75,{"inputs":[],"output":{"name":"removerotation"}}],[11,"control","","",75,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[11,"new","lumol::sim","Create a new `MolecularDynamics` propagator using a `VelocityVerlet` integrator.",76,{"inputs":[{"name":"f64"}],"output":{"name":"moleculardynamics"}}],[11,"from_integrator","","Create a new `MolecularDynamics` propagator using the specified `integrator`.",76,{"inputs":[{"name":"box"}],"output":{"name":"moleculardynamics"}}],[11,"add_control","","Add a control algorithm to the internal list of controls.",76,{"inputs":[{"name":"self"},{"name":"box"}],"output":null}],[11,"set_thermostat","","Set the thermostat to use with this simulation",76,{"inputs":[{"name":"self"},{"name":"box"}],"output":null}],[11,"temperature_strategy","","",76,{"inputs":[{"name":"self"}],"output":{"name":"temperaturestrategy"}}],[11,"setup","","",76,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[11,"propagate","","",76,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[11,"finish","","",76,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[8,"Integrator","lumol::sim::md","The `Integrator` trait define integrator interface for molecular dynamics. An integrator is an algorithm responsible for propagating the equations of motion in the system.",null,null],[11,"setup","","Setup the integrator. This function is called once by every simulation run.",77,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[10,"integrate","","Integrate the equations of motion. This is called at every step of the simulation.",77,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[8,"Control","","Trait for controlling some parameters in a system during a simulation.",null,null],[11,"setup","","Function called once at the beginning of the simulation, which allow for some setup of the control algorithm if needed.",78,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[10,"control","","Do your job, control algorithm!",78,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[11,"finish","","Function called once at the end of the simulation.",78,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[8,"Thermostat","","Trait for controls usable as thermostats",null,null],[0,"mc","lumol::sim","Monte Carlo Metropolis algorithms",null,null],[3,"MonteCarlo","lumol::sim::mc","Metropolis Monte Carlo propagator",null,null],[3,"MoveCounter","","This struct keeps track of the number of times a move was called and how often it was accepted.",null,null],[12,"ncalled","","Count the total number of times the move was called.",79,null],[12,"naccepted","","Count the number of times the move was accepted since the last update.",79,null],[12,"nattempted","","Count the number of times the move was called since the last update.",79,null],[3,"Translate","","Monte Carlo move for translating a molecule",null,null],[3,"Rotate","","Monte Carlo move for rotating a rigid molecule",null,null],[3,"Resize","","Monte Carlo move that changes the size of the simulation cell",null,null],[11,"new","lumol::sim","Create a new Monte Carlo propagator at temperature `T`.",80,{"inputs":[{"name":"f64"}],"output":{"name":"montecarlo"}}],[11,"from_rng","","Create a Monte Carlo propagator at temperature `T`, using the `rng` random number generator.",80,{"inputs":[{"name":"f64"},{"name":"box"}],"output":{"name":"montecarlo"}}],[11,"add","","Add the `mcmove` Monte Carlo move to this propagator, with frequency `frequency`. All calls to this function should happen before any simulation run.",80,{"inputs":[{"name":"self"},{"name":"box"},{"name":"f64"}],"output":null}],[11,"add_move_with_acceptance","","Add the `mcmove` Monte Carlo move to the propagator. `frequency` describes how frequent a move is called, `target_acceptance` is the desired acceptance ratio of the move.",80,{"inputs":[{"name":"self"},{"name":"box"},{"name":"f64"},{"name":"f64"}],"output":null}],[11,"set_amplitude_update_frequency","","Set the number of times a move has to be called before its amplitude is updated. This value is applied to all moves.",80,{"inputs":[{"name":"self"},{"name":"u64"}],"output":null}],[11,"temperature","","Get the temperature of the simulation",80,{"inputs":[{"name":"self"}],"output":{"name":"f64"}}],[11,"set_temperature","","Set the temperature of the simulation",80,{"inputs":[{"name":"self"},{"name":"f64"}],"output":null}],[11,"temperature_strategy","","",80,{"inputs":[{"name":"self"}],"output":{"name":"temperaturestrategy"}}],[11,"setup","","",80,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[11,"propagate","","",80,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[11,"finish","","Print some informations about moves to screen",80,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[11,"new","lumol::sim::mc","Create a new counter for the move, initializing all counts to zero and setting the `target_acceptance`.",79,{"inputs":[{"name":"option"}],"output":{"name":"movecounter"}}],[11,"set_acceptance","","Set the target acceptance for the move counter.",79,{"inputs":[{"name":"self"},{"name":"option"}],"output":null}],[11,"compute_scaling_factor","","Compute a scaling factor according to the desired acceptance.",79,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"new","","Create a new `Translate` move, with maximum displacement of `delta`. Translating all the molecules in the system.",81,{"inputs":[{"name":"f64"}],"output":{"name":"translate"}}],[11,"with_moltype","","Create a new `Translate` move, with maximum displacement of `delta`. Translating only molecules with `moltype` type.",81,{"inputs":[{"name":"f64"},{"name":"u64"}],"output":{"name":"translate"}}],[11,"default","","",81,{"inputs":[],"output":{"name":"translate"}}],[11,"describe","","",81,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"setup","","",81,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[11,"prepare","","",81,{"inputs":[{"name":"self"},{"name":"system"},{"name":"box"}],"output":{"name":"bool"}}],[11,"cost","","",81,{"inputs":[{"name":"self"},{"name":"system"},{"name":"f64"},{"name":"energycache"}],"output":{"name":"f64"}}],[11,"apply","","",81,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[11,"restore","","",81,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[11,"update_amplitude","","",81,{"inputs":[{"name":"self"},{"name":"option"}],"output":null}],[11,"new","","Create a new `Rotate` move, with maximum angular displacement of `theta`, rotating all the molecules in the system.",82,{"inputs":[{"name":"f64"}],"output":{"name":"rotate"}}],[11,"with_moltype","","Create a new `Rotate` move, with maximum angular displacement of `theta`, rotating only molecules with `moltype` type.",82,{"inputs":[{"name":"f64"},{"name":"u64"}],"output":{"name":"rotate"}}],[11,"default","","",82,{"inputs":[],"output":{"name":"rotate"}}],[11,"describe","","",82,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"setup","","",82,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[11,"prepare","","",82,{"inputs":[{"name":"self"},{"name":"system"},{"name":"box"}],"output":{"name":"bool"}}],[11,"cost","","",82,{"inputs":[{"name":"self"},{"name":"system"},{"name":"f64"},{"name":"energycache"}],"output":{"name":"f64"}}],[11,"apply","","",82,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[11,"restore","","",82,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[11,"update_amplitude","","",82,{"inputs":[{"name":"self"},{"name":"option"}],"output":null}],[11,"new","","Create a new `Resize` move, with target pressure `pressure` and maximum displacement of `delta`.",83,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"resize"}}],[11,"describe","","",83,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"setup","","",83,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[11,"prepare","","",83,{"inputs":[{"name":"self"},{"name":"system"},{"name":"box"}],"output":{"name":"bool"}}],[11,"cost","","",83,{"inputs":[{"name":"self"},{"name":"system"},{"name":"f64"},{"name":"energycache"}],"output":{"name":"f64"}}],[11,"apply","","",83,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[11,"restore","","",83,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[11,"update_amplitude","","",83,{"inputs":[{"name":"self"},{"name":"option"}],"output":null}],[8,"MCMove","","The `MCMove` trait correspond to the set of methods used in Monte Carlo simulations.",null,null],[10,"describe","","Give a short description of this move",84,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[10,"setup","","Set up move before simulation is run",84,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[10,"prepare","","Prepare the move by selecting the particles to move, and the parameters of the move. The `rng` random number generator should be used to generate the parameters of the move.",84,{"inputs":[{"name":"self"},{"name":"system"},{"name":"box"}],"output":{"name":"bool"}}],[10,"cost","","Get the cost of performing this move on `system`. For example in simple NVT simulations, this cost is the energetic difference between the new and the old state times beta. The cost must be dimmensionless.",84,{"inputs":[{"name":"self"},{"name":"system"},{"name":"f64"},{"name":"energycache"}],"output":{"name":"f64"}}],[10,"apply","","Apply the move, if it has not already been done in `prepare`.",84,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[10,"restore","","Restore the system to it's initial state if it has been changed in `prepare`.",84,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[10,"update_amplitude","","Update the sample range for displacements.",84,{"inputs":[{"name":"self"},{"name":"option"}],"output":null}],[0,"min","lumol::sim","Energy minimization algorithms",null,null],[3,"Minimization","lumol::sim::min","Minimization propagator for simulations.",null,null],[3,"Tolerance","","Tolerance criteria used for energy minimization",null,null],[12,"energy","","Potential energy of the system",85,null],[12,"force2","","Maximal squared norm of the force acting on an atom",85,null],[3,"SteepestDescent","","Steepest descent minimization algorithm.",null,null],[11,"new","lumol::sim","Create a new `Minimization` using the given `minimizer`.",86,{"inputs":[{"name":"box"}],"output":{"name":"minimization"}}],[11,"with_tolerance","","Create a new `Minimization` using the given `minimizer` and specific energy and force `tolerance`.",86,{"inputs":[{"name":"box"},{"name":"tolerance"}],"output":{"name":"minimization"}}],[11,"converged","","Check if the minimization has converged.",86,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"temperature_strategy","","",86,{"inputs":[{"name":"self"}],"output":{"name":"temperaturestrategy"}}],[11,"setup","","",86,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[11,"propagate","","",86,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[11,"new","lumol::sim::min","Create a new `SteepestDescent` minimizer",87,{"inputs":[],"output":{"name":"steepestdescent"}}],[11,"minimize","","",87,{"inputs":[{"name":"self"},{"name":"system"}],"output":{"name":"tolerance"}}],[8,"Minimizer","","The `Minimizer` trait define minimization interface.",null,null],[11,"setup","","Setup the minimizer. This function is called once at the begining of every simulation run.",88,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[10,"minimize","","Find a new configuration of lower energy, and return the corresponding values for energy and forces.",88,{"inputs":[{"name":"self"},{"name":"system"}],"output":{"name":"tolerance"}}],[11,"new","lumol::sim","Create a new Simulation from a Propagator.",89,{"inputs":[{"name":"box"}],"output":{"name":"simulation"}}],[11,"run","","Run the simulation on System for `nsteps` steps.",89,{"inputs":[{"name":"self"},{"name":"system"},{"name":"usize"}],"output":null}],[11,"add_output","","Add a new `Output` algorithm in the outputs list",89,{"inputs":[{"name":"self"},{"name":"box"}],"output":null}],[11,"add_output_with_frequency","","Add a new `Output` algorithm in the outputs list, which will be used at the given frequency. The output will be used every time the system step matches this frequency.",89,{"inputs":[{"name":"self"},{"name":"box"},{"name":"u64"}],"output":null}],[11,"fmt","","",73,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Wrap the algorithm `base` to call it only every `every` time.",73,{"inputs":[{"name":"u64"},{"name":"t"}],"output":{"name":"alternator"}}],[11,"can_run","","Check if this is the appropriate time to run the algorithm.",73,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"as_ref","","Access the base algorithm as a reference.",73,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"as_mut","","Access the base algorithm as a mutable reference.",73,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[8,"Propagator","","The propagator trait is the main algorithm of a simulation, i.e. the one which update the system. The main function here is `propagate`, which should propagate the simulation for one step.",null,null],[11,"setup","","Setup code, preparing all the meta-information needed about the simulation.",90,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[10,"temperature_strategy","","Get the temperature computation strategy for this propagator",90,{"inputs":[{"name":"self"}],"output":{"name":"temperaturestrategy"}}],[10,"propagate","","Propagate the system for one simulation step.",90,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[11,"finish","","Finish the simulation, and maybe output some information about it",90,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[0,"out","lumol","Saving properties of a system during a simulation",null,null],[3,"CellOutput","lumol::out","The `CellOutput` writes all the components of a cell to a file . The columns in the file contain the following values: `A B C α β γ`.",null,null],[3,"EnergyOutput","","The `EnergyOutput` writes the energy of the system to a text file, organized as: `PotentialEnergy KineticEnergy TotalEnergy`.",null,null],[3,"CustomOutput","","The `CustomOutput` writes data into a file from an user-provided template.",null,null],[3,"PropertiesOutput","","The `PropertiesOutput` write various physical properties of the system to a file. These properties are:",null,null],[3,"TrajectoryOutput","","The `TrajectoryOutput` allows to write the trajectory of the system to a file, using any format supported by the [Chemfiles][chemfiles] library.",null,null],[4,"CustomOutputError","","Possible causes of error when using a custom output",null,null],[13,"Io","","Any IO error",91,null],[13,"Expr","","Error in the mathematical expression",91,null],[13,"Custom","","Any other error",91,null],[11,"new","","Create a new `CellOutput` writing to `filename`. The file is replaced if it already exists.",92,{"inputs":[{"name":"p"}],"output":{"name":"result"}}],[11,"setup","","",92,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[11,"write","","",92,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[11,"new","","Create a new `EnergyOutput` writing to `filename`. The file is replaced if it already exists.",93,{"inputs":[{"name":"p"}],"output":{"name":"result"}}],[11,"setup","","",93,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[11,"write","","",93,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[11,"fmt","","",91,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",91,{"inputs":[{"name":"error"}],"output":{"name":"customoutputerror"}}],[11,"from","","",91,{"inputs":[{"name":"caldynerror"}],"output":{"name":"customoutputerror"}}],[11,"from","","",91,{"inputs":[{"name":"string"}],"output":{"name":"customoutputerror"}}],[11,"fmt","","",91,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","",91,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"cause","","",91,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"new","","Create a new `CustomOutput` writing to the file at `filename` using the given `template`. The `template` is only partially validated at this stage.",94,{"inputs":[{"name":"p"},{"name":"str"}],"output":{"name":"result"}}],[11,"setup","","",94,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[11,"write","","",94,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[11,"new","","Create a new `PropertiesOutput` writing to `filename`. The file is replaced if it already exists.",95,{"inputs":[{"name":"p"}],"output":{"name":"result"}}],[11,"setup","","",95,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[11,"write","","",95,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[11,"new","","Create a new `TrajectoryOutput` writing to `filename`. The file is replaced if it already exists. The file format is guessed from the extension. Please refer to the list of [supported formats][formats] for more information.",96,{"inputs":[{"name":"p"}],"output":{"name":"result"}}],[11,"with_format","","Create a new `TrajectoryOutput` writing to `filename` using the given `format`. The file is replaced if it already exists.",96,{"inputs":[{"name":"p"},{"name":"str"}],"output":{"name":"result"}}],[11,"write","","",96,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[8,"Output","","The `Output` trait defines the interface for all the quantities outputted by the simulation during the run. An Output can be a text or a binary data file, an image, a text log, …",null,null],[11,"setup","","Function called once at the beginning of the simulation, which allows for some setup of the output if needed.",97,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[10,"write","","Write the output from the system.",97,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[11,"finish","","Function called once at the end of the simulation.",97,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[0,"parallel","lumol","Parallelism related utilities",null,null],[3,"ThreadLocalStore","lumol::parallel","A simple struct that delivers thread local variables.",null,null],[0,"prelude","","Combination of `rayon::prelude` and lumol specific utilities",null,null],[8,"ParallelShortcuts","lumol::parallel::prelude","Utility trait that adds shortcuts for `IntoParallelIterator` structs.",null,null],[16,"Iter","","The iterator type",98,null],[10,"par_map","","Shortcut for `into_par_iter().map()`",98,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"map"}}],[11,"into_iter","lumol::parallel","",99,null],[11,"new","","Create a new `ThreadLocalStore`.",99,{"inputs":[{"name":"f"}],"output":{"name":"self"}}],[11,"sum_local_values","","Shortcut to sum the local values if the local data can be iterated into `AddAssign` items.",99,null],[11,"deref","","",99,null],[8,"ParallelShortcuts","","Utility trait that adds shortcuts for `IntoParallelIterator` structs.",null,null],[16,"Iter","","The iterator type",98,null],[10,"par_map","","Shortcut for `into_par_iter().map()`",98,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"map"}}],[11,"setup","lumol::sim","Setup code, preparing all the meta-information needed about the simulation.",90,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[11,"finish","","Finish the simulation, and maybe output some information about it",90,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[11,"setup","lumol::sim::md","Setup the integrator. This function is called once by every simulation run.",77,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[11,"setup","","Function called once at the beginning of the simulation, which allow for some setup of the control algorithm if needed.",78,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[11,"finish","","Function called once at the end of the simulation.",78,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}],[11,"setup","lumol::sim::min","Setup the minimizer. This function is called once at the begining of every simulation run.",88,{"inputs":[{"name":"self"},{"name":"system"}],"output":null}]],"paths":[[4,"ParseError"],[8,"One"],[8,"Zero"],[3,"Vector3D"],[3,"Matrix3"],[3,"Complex"],[3,"Array2"],[3,"Array3"],[3,"LennardJones"],[3,"Harmonic"],[3,"Torsion"],[3,"Buckingham"],[3,"BornMayerHuggins"],[3,"MorsePotential"],[3,"RestrictionInfo"],[4,"PairRestriction"],[3,"NullPotential"],[3,"CosineHarmonic"],[3,"TableComputation"],[3,"Wolf"],[3,"Ewald"],[3,"SharedEwald"],[3,"PairInteraction"],[8,"Potential"],[8,"PairPotential"],[8,"BondPotential"],[8,"Computation"],[8,"GlobalPotential"],[8,"GlobalCache"],[8,"CoulombicPotential"],[3,"ElementData"],[3,"Particle"],[3,"ParticleKind"],[3,"Configuration"],[4,"CellShape"],[4,"OpenMode"],[3,"PeriodicTable"],[3,"Composition"],[3,"UnitCell"],[3,"BondDistance"],[3,"Bond"],[3,"Angle"],[3,"Dihedral"],[3,"Molecule"],[3,"System"],[3,"EnergyEvaluator"],[3,"EnergyCache"],[3,"TrajectoryError"],[3,"TrajectoryBuilder"],[3,"Trajectory"],[8,"InitVelocities"],[3,"BoltzmannVelocities"],[3,"UniformVelocities"],[3,"PressureAtTemperature"],[3,"StressAtTemperature"],[8,"Compute"],[3,"Forces"],[3,"PotentialEnergy"],[3,"KineticEnergy"],[3,"TotalEnergy"],[3,"Temperature"],[3,"Volume"],[3,"Virial"],[3,"Stress"],[3,"Pressure"],[4,"TemperatureStrategy"],[3,"VelocityVerlet"],[3,"Verlet"],[3,"LeapFrog"],[3,"BerendsenBarostat"],[3,"AnisoBerendsenBarostat"],[3,"RescaleThermostat"],[3,"BerendsenThermostat"],[3,"Alternator"],[3,"RemoveTranslation"],[3,"RemoveRotation"],[3,"MolecularDynamics"],[8,"Integrator"],[8,"Control"],[3,"MoveCounter"],[3,"MonteCarlo"],[3,"Translate"],[3,"Rotate"],[3,"Resize"],[8,"MCMove"],[3,"Tolerance"],[3,"Minimization"],[3,"SteepestDescent"],[8,"Minimizer"],[3,"Simulation"],[8,"Propagator"],[4,"CustomOutputError"],[3,"CellOutput"],[3,"EnergyOutput"],[3,"CustomOutput"],[3,"PropertiesOutput"],[3,"TrajectoryOutput"],[8,"Output"],[8,"ParallelShortcuts"],[3,"ThreadLocalStore"]]};
searchIndex["lumol_input"] = {"doc":"This crate provide a way to build a Lumol simulation using input files.","items":[[3,"InteractionsInput","lumol_input","An interaction input file for Lumol.",null,null],[3,"Input","","An input file for Lumol.",null,null],[3,"Config","","A configuration about how to run a single simulation. This contains the system to simulate, the simulation itself and the number of steps to run the simulation.",null,null],[12,"system","","The simulated system",0,null],[12,"simulation","","The simulation object",0,null],[12,"nsteps","","The simulation duration",0,null],[4,"Error","","Possible causes of error when reading input files",null,null],[13,"TOML","","Error in the TOML input file",1,null],[13,"Io","","IO error, and associated file path",1,null],[13,"Trajectory","","Error while reading a trajectory file",1,null],[13,"Config","","File content error: missing sections, bad data types",1,null],[13,"Unit","","Unit parsing error",1,null],[13,"CustomOutput","","Specific error from the custom outputs",1,null],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",1,null],[11,"from","","",1,{"inputs":[{"name":"trajectoryerror"}],"output":{"name":"error"}}],[11,"from","","",1,{"inputs":[{"name":"error"}],"output":{"name":"error"}}],[11,"from","","",1,{"inputs":[{"name":"str"}],"output":{"name":"error"}}],[11,"from","","",1,{"inputs":[{"name":"string"}],"output":{"name":"error"}}],[11,"from","","",1,{"inputs":[{"name":"parseerror"}],"output":{"name":"error"}}],[11,"from","","",1,null],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","",1,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"cause","","",1,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"new","","Read interactions from the TOML formatted file at `path`.",2,{"inputs":[{"name":"p"}],"output":{"name":"result"}}],[11,"read","","Read the interactions from this input into the `system`.",2,{"inputs":[{"name":"self"},{"name":"system"}],"output":{"name":"result"}}],[11,"read_system","","Get the the simulated system.",3,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"read_simulation","","Get the the simulation.",3,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"new","","Read the file at `Path` and create a new `Input` from it.",3,{"inputs":[{"name":"p"}],"output":{"name":"result"}}],[11,"read","","Read input file and get the corresponding `Config`",3,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[6,"Result","","Custom `Result` type for input files",null,null],[8,"FromToml","","Convert a TOML table to a Rust type.",null,null],[10,"from_toml","","Do the conversion from `table` to Self.",4,{"inputs":[{"name":"table"}],"output":{"name":"result"}}],[8,"FromTomlWithData","","Convert a TOML table and some additional data to a Rust type.",null,null],[16,"Data","","The type of the additional data needed.",5,null],[10,"from_toml","","Do the conversion from `table` and `data` to Self.",5,null]],"paths":[[3,"Config"],[4,"Error"],[3,"InteractionsInput"],[3,"Input"],[8,"FromToml"],[8,"FromTomlWithData"]]};
initSearch(searchIndex);
